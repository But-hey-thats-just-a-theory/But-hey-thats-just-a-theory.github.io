@page "/World/Bank/"
@inject GameState GameState
@implements IDisposable

<h3>Bank</h3>
<div>
    Quantity:
    <div>
        <button class="btn btn-primary" style="@GetButtonStyle(1)" @onclick="@(() => UpdateBankAmount(1))">1</button>
        <button class="btn btn-primary" style="@GetButtonStyle(5)" @onclick="@(() => UpdateBankAmount(5))">5</button>
        <button class="btn btn-primary" style="@GetButtonStyle(10)" @onclick="@(() => UpdateBankAmount(10))">10</button>
        <button class="btn btn-primary" style="@GetButtonStyle(20)" @onclick="@(() => UpdateBankAmount(20))">x</button>
        <button class="btn btn-primary" style="@GetButtonStyle(int.MaxValue)" @onclick="@(() => UpdateBankAmount(int.MaxValue))">All</button>
    </div>
    <div>
       <button class="btn btn-primary" @onclick="@(() => DepositAll())">Deposit All</button>
    </div>
</div>

        @if (NPCManager.Instance.GetNPCByName("Tuto").AvailableDialogCount() > 0)
        {
            <Quepland_2.Components.NPCDialogComponent npc="Tuto"></Quepland_2.Components.NPCDialogComponent>
        }

<div style="display:flex;flex-wrap:wrap;">
    @foreach (GameItem item in Bank.Instance.Inventory.GetItems().Keys)
    {
        <div @onclick="@(() => Withdraw(item))">
            <Quepland_2.Components.ItemBoxComponent Item="@item" ShowAmount="@true" Inventory="@Bank.Instance.Inventory"></Quepland_2.Components.ItemBoxComponent>

        </div>
    }
    @for (int i = 0; i < GetEmptyItemsToFillRow(); i++)
    {
        int temp = i;
        if (temp % itemsPerRow == 0)
        {
            <br />
        }
        <Quepland_2.Components.ItemBoxComponent Item="@null"></Quepland_2.Components.ItemBoxComponent>
    }
</div>
@code {
    int itemsPerRow = 10;
    private int GetEmptyItemsToFillRow()
    {
        return itemsPerRow - (Bank.Instance.Inventory.GetItems().Keys.Count % itemsPerRow);
    }
    private void Withdraw(GameItem item)
    {


        int maxWithdraw = Math.Max(0, Bank.Instance.Amount);
        //If the item is stackable and the player has a stack in their inventory already, or the player has space for another item
        if ((item.IsStackable && Player.Instance.Inventory.HasItem(item) && Player.Instance.Inventory.GetAvailableSpaces() == 0) ||
         (item.IsStackable && Player.Instance.Inventory.GetAvailableSpaces() > 0))
        {
            maxWithdraw = Math.Min(Bank.Instance.Amount, Bank.Instance.Inventory.GetNumberOfItem(item));
        }
        else
        {
            //Gets the smallest of the amount, inventory space, and number in the bank.
            maxWithdraw = Math.Min(Math.Min(Bank.Instance.Amount, Player.Instance.Inventory.GetAvailableSpaces()), Bank.Instance.Inventory.GetNumberOfItem(item));
        }
        if (Player.Instance.Inventory.AddMultipleOfItem(item, maxWithdraw))
        {
            Bank.Instance.Inventory.RemoveItems(item, maxWithdraw);
        }
        GameState.UpdateState();
    }
    public void DepositAll()
    {
        Bank.Instance.DepositAll();
        GameState.UpdateState();
    }
    private string GetButtonStyle(int amount)
    {
        if (Bank.Instance.Amount == amount)
        {
            return "cursor:normal;background-color:darkgray;";
        }
        else
        {
            return "cursor:pointer;";
        }
    }

    private void UpdateBankAmount(int newAmount)
    {
        Bank.Instance.Amount = newAmount;
        GameState.UpdateState();
    }
    protected override void OnInitialized()
    {
        Bank.Instance.IsBanking = true;
        GameState.StateChanged += OnGameStateChanged;
    }
    public void Dispose()
    {
        Bank.Instance.IsBanking = false;
        GameState.StateChanged -= OnGameStateChanged;
    }
    void OnGameStateChanged(object sender, EventArgs e) => StateHasChanged();
}
